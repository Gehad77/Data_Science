{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "confirmed-competition",
   "metadata": {
    "id": "confirmed-competition"
   },
   "source": [
    "# 01 NumPy\n",
    "\n",
    "NumPy’s main object is the homogeneous multidimensional array. It is a table of elements (usually\n",
    "numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions\n",
    "are called axes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "violent-collector",
   "metadata": {
    "id": "violent-collector"
   },
   "outputs": [],
   "source": [
    "import numpy as np #  aliase name   array 4x2 "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "freelance-sheffield",
   "metadata": {
    "id": "freelance-sheffield"
   },
   "source": [
    "## 1. Array Creation\n",
    "* np.array()\n",
    "* np.zeros()\n",
    "* np.ones()\n",
    "* np.empty()\n",
    "* np.eye()\n",
    "* np.asarray()\n",
    "* numpy.arange()\n",
    "* np.linspace()\n",
    "### 1.1 np.array()\n",
    "Create an array.\n",
    "\n",
    "* np.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "id": "referenced-amazon",
   "metadata": {
    "id": "referenced-amazon",
    "outputId": "4f5b71f7-a4f6-439f-8437-c30df6c227bd"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "one-dimensional array: [1 2 3 4 5 6]\n"
     ]
    }
   ],
   "source": [
    "a = np.array([1,2,3,4,5,6]) # create a one-dimensional array\n",
    "print(\"one-dimensional array:\", a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "instructional-parameter",
   "metadata": {
    "id": "instructional-parameter",
    "outputId": "4a3308f8-9b4b-4282-e1cc-0de37a3f5bf7"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "multidimensional array: \n",
      " [[1 2 3]\n",
      " [4 5 6]\n",
      " [7 8 9]]\n"
     ]
    }
   ],
   "source": [
    "b = np.array([[1,2,3],[4,5,6],[7,8,9]]) # create a multidimensional array  [[row1],[row2],[row3]]\n",
    "print(\"multidimensional array:\",'\\n' ,b) #3x3 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "optimum-accommodation",
   "metadata": {
    "id": "optimum-accommodation",
    "outputId": "d3443060-97bf-47c6-d531-5f6933f6dd47"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "multidimensional array: \n",
      " [[1 2 3]\n",
      " [4 5 6]]\n"
     ]
    }
   ],
   "source": [
    "a=np.array([(1,2,3),(4,5,6)])\n",
    "print(\"multidimensional array:\" ,'\\n',a)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "advanced-gamma",
   "metadata": {
    "id": "advanced-gamma"
   },
   "source": [
    "### 1.2 np.zeros(), np.ones(), np.empty()\n",
    "Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers\n",
    "\n",
    "several functions to create arrays with initial placeholder content. These minimize the necessity of\n",
    "growing arrays, an expensive operation.\n",
    "\n",
    "The function zeros creates an array full of zeros, the function ones creates an array full of ones,\n",
    "and the function empty creates an array whose initial content is random and depends on the state\n",
    "of the memory. By default, the dtype of the created array is float64. \n",
    "\n",
    "* np.zeros(shape, dtype=float,order='C')\n",
    "* np.zeros(shape, dtype=float, order='C')\n",
    "* np.ones(shape, dtype=None, order='C')\n",
    "* np.empty(shape, dtype=float, order='C')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "undefined-firewall",
   "metadata": {
    "id": "undefined-firewall",
    "outputId": "59694cc1-ddf5-41bc-ac94-9097100c0b25"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "array full of zeros: \n",
      " [[0. 0.]\n",
      " [0. 0.]]\n"
     ]
    }
   ],
   "source": [
    "c = np.zeros([2,2]) #([row,col])\n",
    "print(\"array full of zeros:\",'\\n',c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "another-dinner",
   "metadata": {
    "id": "another-dinner",
    "outputId": "13cb4b64-d6c2-4a19-f3d7-0fc0c41661c6"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "array full of zeros: \n",
      " [[0. 0.]\n",
      " [0. 0.]]\n"
     ]
    }
   ],
   "source": [
    "c = np.zeros((2,2)) #((row,col))\n",
    "print(\"array full of zeros:\",'\\n',c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "rolled-royalty",
   "metadata": {
    "id": "rolled-royalty",
    "outputId": "55a4aae6-be69-47df-ce1d-202a0395c152"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "array full of ones: \n",
      " [[1. 1. 1.]\n",
      " [1. 1. 1.]\n",
      " [1. 1. 1.]]\n"
     ]
    }
   ],
   "source": [
    "d = np.ones([3,3])#([row,col])\n",
    "print(\"array full of ones: \\n\",d)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "changing-platinum",
   "metadata": {
    "id": "changing-platinum",
    "outputId": "a2c14cbc-3411-45e5-9e65-19c8b8ae0ce1"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "array full of ones: \n",
      " [[1. 1.]\n",
      " [1. 1.]]\n"
     ]
    }
   ],
   "source": [
    "d = np.ones((2,2))\n",
    "print(\"array full of ones: \\n\",d)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "armed-church",
   "metadata": {
    "id": "armed-church"
   },
   "source": [
    "### 1.3 np.eye()\n",
    "create identity matrix\n",
    "\n",
    "Return a 2-D array with ones on the diagonal and zeros elsewhere.\n",
    "\n",
    "np.eye(N, M=None, k=0, dtype=float, order='C')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "suited-tongue",
   "metadata": {
    "id": "suited-tongue",
    "outputId": "9a5f3c4e-5942-4aea-dbc5-6eb24efc2d68"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1. 0. 0. 0. 0.]\n",
      " [0. 1. 0. 0. 0.]\n",
      " [0. 0. 1. 0. 0.]\n",
      " [0. 0. 0. 1. 0.]\n",
      " [0. 0. 0. 0. 1.]]\n"
     ]
    }
   ],
   "source": [
    "print(np.eye(5)) ## square matrix"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "statutory-magic",
   "metadata": {
    "id": "statutory-magic"
   },
   "source": [
    "### 1.4 np.asarray()\n",
    "\n",
    "Convert the input to an array.\n",
    "\n",
    "np.asarray(a, dtype = None, order = None)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "alpha-october",
   "metadata": {
    "id": "alpha-october",
    "outputId": "147d1a26-4f47-44fe-82d9-f9d39e703b47"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "one-dimensional array: \n",
      " [1 2 3 4 5 6]\n"
     ]
    }
   ],
   "source": [
    "e = np.asarray([1,2,3,4,5,6])\n",
    "print(\"one-dimensional array: \\n\", e)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "encouraging-cambodia",
   "metadata": {
    "id": "encouraging-cambodia"
   },
   "source": [
    "### 1.5 the difference between array() and asarray()\n",
    "\n",
    "The main difference is that array (by default) will make a copy of the object, while asarray will not\n",
    "unless necessary."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "temporal-binary",
   "metadata": {
    "id": "temporal-binary",
    "outputId": "d9a8fb22-61e3-41d4-b2ae-04a8c480930a"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "data:  False\n",
      "data: False\n",
      "data:  True\n",
      "data: False\n"
     ]
    }
   ],
   "source": [
    "a = np.array([1, 2], dtype=np.float32)\n",
    "\n",
    "print(\"data: \",np.array(a, dtype=np.float32) is a)\n",
    "print(\"data:\",np.array(a, dtype=np.float64) is a)\n",
    "print(\"data: \",np.asarray(a, dtype=np.float32) is a)\n",
    "print(\"data:\",np.asarray(a, dtype=np.float64) is a)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "8e714856-22b7-4fe0-98e2-76dbc8882f9c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[3. 2.]\n",
      "[3. 2.]\n",
      "[1. 2.]\n"
     ]
    }
   ],
   "source": [
    "a_copy1=np.asarray(a, dtype=np.float32)\n",
    "a_copy2=np.array(a, dtype=np.float32)\n",
    "\n",
    "a_copy1[0]=3\n",
    "print(a)\n",
    "print(a_copy1)\n",
    "print(a_copy2)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "modular-timer",
   "metadata": {
    "id": "modular-timer"
   },
   "source": [
    "### 1.6 np.arange()\n",
    "To create sequences of numbers, NumPy provides the arange function which is analogous to the\n",
    "Python built-in range, but returns an array.\n",
    "\n",
    "numpy.arange([start, ]stop, [step, ]dtype=None)\n",
    "\n",
    " * start: number, optional; Start of interval. The interval includes this value. The default start value is 0.\n",
    " * stop: number,End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point         round-off affects the length of out.\n",
    " * step: number, optional; Spacing between values. For any output out, this is the distance between two adjacent values, out[i+1] - out[i]. The         default step size is 1. If step is specified as a position argument, start must also be given."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "processed-workstation",
   "metadata": {
    "id": "processed-workstation",
    "outputId": "b374b0d6-8a9a-40d8-fbb9-b9c3af071ec3"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sequences of numbers in array: [10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56\n",
      " 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98]\n"
     ]
    }
   ],
   "source": [
    "f = np.arange(10,100,2)\n",
    "print(\"sequences of numbers in array:\",f)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "agreed-proposal",
   "metadata": {
    "id": "agreed-proposal"
   },
   "source": [
    "### 1.7 np.linspace()\n",
    "\n",
    "Return evenly spaced numbers over a specified interval.\n",
    "\n",
    "Returns num evenly spaced samples, calculated over the interval [start, stop].\n",
    "\n",
    "The endpoint of the interval can optionally be excluded.\n",
    "\n",
    " * np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "hidden-specification",
   "metadata": {
    "id": "hidden-specification",
    "outputId": "5aebb53c-caf1-43b8-849b-fafd834aaf9d"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "array([0.        , 0.05263158, 0.10526316, 0.15789474, 0.21052632,\n       0.26315789, 0.31578947, 0.36842105, 0.42105263, 0.47368421,\n       0.52631579, 0.57894737, 0.63157895, 0.68421053, 0.73684211,\n       0.78947368, 0.84210526, 0.89473684, 0.94736842, 1.        ])"
     },
     "execution_count": 59,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "h=np.linspace(0,1,20)\n",
    "h"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "celtic-observer",
   "metadata": {
    "id": "celtic-observer",
    "outputId": "5dd53cb4-7f57-406e-bc27-61b5d616e759"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 0. 11. 22. 33. 44. 55. 66. 77. 88. 99.]\n"
     ]
    }
   ],
   "source": [
    "g = np.linspace(0,99,10)\n",
    "print(g)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "detailed-attempt",
   "metadata": {
    "id": "detailed-attempt"
   },
   "source": [
    "## 2. Important attributes of an ndarray object\n",
    "\n",
    "* ndarray.ndim\n",
    "\n",
    "  the number of axes (dimensions) of the array.\n",
    "  \n",
    "* ndarray.shape\n",
    "\n",
    "    the dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension. For a matrix with n rows and m     columns, shape will be (n,m). The length of the shape tuple is therefore the number of axes, ndim.\n",
    "    \n",
    "* ndarray.size\n",
    "\n",
    "  the total number of elements of the array. This is equal to the product of the elements of shape.\n",
    "  \n",
    "* ndarray.dtype\n",
    "\n",
    "    an object describing the type of the elements in the array. One can create or specify dtype’s using standard Python types. Additionally         NumPy provides types of its own.\n",
    "    numpy.int32, numpy.int16, and numpy.float64 are some examples.\n",
    "    \n",
    "* ndarray.itemsize\n",
    "\n",
    "    the size in bytes of each element of the array. For example, an array of elements of type float64 has itemsize 8 (=64/8), while one of type     complex32 has itemsize 4 (=32/8). It is equivalent to ndarray.dtype.itemsize.\n",
    "    \n",
    "* ndarray.data\n",
    "\n",
    "    the buffer containing the actual elements of the array. Normally, we won’t need to use this attribute because we will access the elements       in an array using indexing facilities."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "preliminary-schedule",
   "metadata": {
    "id": "preliminary-schedule",
    "outputId": "71709fb2-62c3-4f7e-f71d-8cd5a9a8cf3c"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "(3, 2)"
     },
     "execution_count": 61,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = np.array([[1,2],[3,4],[5,6]],dtype=np.float32)  #3*2\n",
    "a.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "talented-offering",
   "metadata": {
    "id": "talented-offering",
    "outputId": "9e801a7a-acab-4d2d-cf1a-a7b8d846629d"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "6"
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a.size"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "id": "compound-stadium",
   "metadata": {
    "id": "compound-stadium",
    "outputId": "bd8b52ad-99c4-4c07-96a8-041bd4f9c9fa"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "2"
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a.ndim"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "id": "bulgarian-hometown",
   "metadata": {
    "id": "bulgarian-hometown",
    "outputId": "5c40b637-b33c-484f-f935-8f957d58e0fe"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "dtype('float32')"
     },
     "execution_count": 64,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a.dtype"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cheap-seeking",
   "metadata": {
    "id": "cheap-seeking"
   },
   "source": [
    "## 3. Indexing, Slicing and Iterating\n",
    "\n",
    "ndrrays can be indexed, sliced and iterated over, much like lists and other Python sequences."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "id": "stupid-violation",
   "metadata": {
    "id": "stupid-violation",
    "outputId": "d07cd3b1-289e-44b2-c036-1db328261a1c"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a: \n",
      " [[1 2]\n",
      " [3 4]]\n",
      "b: 2\n"
     ]
    }
   ],
   "source": [
    "a = np.array([[1, 2], [3, 4]])\n",
    "b = a[0][1]\n",
    "print('a: \\n',a)\n",
    "print('b:',b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "id": "complex-filling",
   "metadata": {
    "id": "complex-filling",
    "outputId": "fb4437ac-01ae-47b5-cd52-c916c86006a2"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "array([[1, 2]])"
     },
     "execution_count": 66,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a[0:1,0:2]       #a[first_index :lastindex+1, first_index:last_index+1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "id": "sticky-tender",
   "metadata": {
    "id": "sticky-tender",
    "outputId": "205a68bc-b4a0-4771-ca94-bc91b7028f3c"
   },
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "list indices must be integers or slices, not tuple",
     "output_type": "error",
     "traceback": [
      "\u001B[1;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[1;31mTypeError\u001B[0m                                 Traceback (most recent call last)",
      "Input \u001B[1;32mIn [67]\u001B[0m, in \u001B[0;36m<cell line: 2>\u001B[1;34m()\u001B[0m\n\u001B[0;32m      1\u001B[0m l\u001B[38;5;241m=\u001B[39m[[\u001B[38;5;241m1\u001B[39m, \u001B[38;5;241m2\u001B[39m], [\u001B[38;5;241m3\u001B[39m, \u001B[38;5;241m4\u001B[39m]]\n\u001B[1;32m----> 2\u001B[0m \u001B[43ml\u001B[49m\u001B[43m[\u001B[49m\u001B[38;5;241;43m0\u001B[39;49m\u001B[43m:\u001B[49m\u001B[38;5;241;43m1\u001B[39;49m\u001B[43m,\u001B[49m\u001B[38;5;241;43m0\u001B[39;49m\u001B[43m:\u001B[49m\u001B[38;5;241;43m2\u001B[39;49m\u001B[43m]\u001B[49m\n",
      "\u001B[1;31mTypeError\u001B[0m: list indices must be integers or slices, not tuple"
     ]
    }
   ],
   "source": [
    "l=[[1, 2], [3, 4]]\n",
    "l[0:1,0:2]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "id": "elegant-allergy",
   "metadata": {
    "id": "elegant-allergy",
    "outputId": "161175a4-b9a3-4d91-eb2e-a939a9dd6b3f"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "array([[1, 2]])"
     },
     "execution_count": 68,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a[0:1][0:2]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "id": "described-software",
   "metadata": {
    "id": "described-software",
    "outputId": "42971c44-1c8b-4793-94f7-a72d770fff48"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[2 4 6]\n",
      "[2 3 4 5 6 7]\n",
      "2\n",
      "[2 3 4 5 6 7 8 9]\n"
     ]
    }
   ],
   "source": [
    "# Slicing\n",
    "a = np.arange(10)\n",
    "\n",
    "print(a[2:8:2])\n",
    "print(a[2:8])\n",
    "print(a[2])\n",
    "print(a[2:])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "arctic-large",
   "metadata": {
    "id": "arctic-large"
   },
   "source": [
    "\n",
    "\n",
    "\n",
    "## 4. Change the shape of an array\n",
    "\n",
    "Gives a new shape to an array without changing its data.\n",
    "\n",
    "* numpy.reshape(a, newshape, order='C')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "id": "coastal-mineral",
   "metadata": {
    "id": "coastal-mineral",
    "outputId": "ecc79b59-f492-4f28-ba5e-18dc547317ca"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0 1 2 3 4 5]\n",
      "[[0 1 2]\n",
      " [3 4 5]]\n"
     ]
    }
   ],
   "source": [
    "a = np.arange(6)\n",
    "\n",
    "b = a.reshape(2,3) # rows,cols\n",
    "print(a)\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "welsh-appreciation",
   "metadata": {
    "id": "welsh-appreciation"
   },
   "source": [
    "## 5. Broadcasting\n",
    "\n",
    "The term broadcasting describes how numpy treats arrays with different shapes during arithmetic\n",
    "operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array\n",
    "so that they have compatible shapes. Broadcasting provides a means of vectorizing array\n",
    "operations so that looping occurs in C instead of Python. It does this without making needless\n",
    "copies of data and usually leads to efficient algorithm implementations. There are, however, cases\n",
    "where broadcasting is a bad idea because it leads to inefficient use of memory that slows\n",
    "computation.\n",
    "\n",
    "NumPy operations are usually done on pairs of arrays on an element-by-element basis. In the\n",
    "simplest case, the two arrays must have exactly the same shape,"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "id": "regulated-alaska",
   "metadata": {
    "id": "regulated-alaska",
    "outputId": "b90fed0f-dab4-4f02-f526-90d9354baf9a"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 1  4  9 16]\n"
     ]
    }
   ],
   "source": [
    "a = np.array([1,2,3,4])\n",
    "b = np.array([1,2,3,4])\n",
    "c = a * b\n",
    "print(c)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "victorian-marsh",
   "metadata": {
    "id": "victorian-marsh"
   },
   "source": [
    "When operating on two arrays, NumPy compares their shapes element-wise. It starts with the\n",
    "\n",
    "trailing dimensions and works its way forward. Two dimensions are compatible when\n",
    "\n",
    "* they are equal, or\n",
    "* one of them is 1\n",
    "\n",
    "If these conditions are not met, a ValueError: operands could not be broadcast together exception\n",
    "is thrown, indicating that the arrays have incompatible shapes. The size of the resulting array is the\n",
    "size that is not 1 along each axis of the inputs.\n",
    "\n",
    "Arrays do not need to have the same number of dimensions. For example, if you have a\n",
    "256x256x3 array of RGB values, and you want to scale each color in the image by a different\n",
    "value, you can multiply the image by a one-dimensional array with 3 values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "id": "informal-prompt",
   "metadata": {
    "id": "informal-prompt",
    "outputId": "b101aa69-a4fa-4d11-da77-020a3634ddf1"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3, 3)\n",
      "(3,)\n",
      "b = \n",
      " [1 2 3]\n"
     ]
    }
   ],
   "source": [
    "a = np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])\n",
    "b = np.array([1, 2, 3])                              \n",
    "print(a.shape)  \n",
    "print(b.shape)\n",
    "print(\"b = \\n\",b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "id": "separated-attraction",
   "metadata": {
    "id": "separated-attraction",
    "outputId": "e272a266-2aeb-4d66-98f6-b9e0ec317212"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "array([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]])"
     },
     "execution_count": 73,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.array([b,b,b])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "id": "alive-abuse",
   "metadata": {
    "id": "alive-abuse",
    "outputId": "8532e981-322a-4cf7-a8c4-0f3ae2d501ad"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a:\n",
      " [[1 2 3]\n",
      " [4 5 6]\n",
      " [7 8 9]]\n",
      "broadcasting:\n",
      " [[ 2  4  6]\n",
      " [ 5  7  9]\n",
      " [ 8 10 12]]\n"
     ]
    }
   ],
   "source": [
    "c = a + b\n",
    "print(\"a:\\n\",a)\n",
    "print(\"broadcasting:\\n\",c)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "chubby-mother",
   "metadata": {
    "id": "chubby-mother"
   },
   "source": [
    "## 6. NumPy common functions\n",
    "\n",
    "### 6.1 ndarray.flat()\n",
    "\n",
    "A 1-D iterator over the array.\n",
    "\n",
    "This is a numpy.flatiter instance, which acts similarly to, but is not a subclass of, Python’s built-in\n",
    "iterator object."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "id": "critical-argentina",
   "metadata": {
    "id": "critical-argentina",
    "outputId": "eb4aa4b7-f341-4285-a592-bc9247496b1c"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 2 3]\n",
      " [4 5 6]\n",
      " [7 8 9]]\n"
     ]
    }
   ],
   "source": [
    "a = np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])\n",
    "print(a)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "id": "judicial-skirt",
   "metadata": {
    "id": "judicial-skirt",
    "outputId": "42d9b5d3-0f29-4558-c2f0-ac1ef9ac14bd"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1 2 3 4 5 6 7 8 9]\n"
     ]
    }
   ],
   "source": [
    "print(a.flat[:])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "descending-smooth",
   "metadata": {
    "id": "descending-smooth"
   },
   "source": [
    "### 6.2 ndarray.transpose()\n",
    "Returns a view of the array with axes transposed"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "id": "natural-blackjack",
   "metadata": {
    "id": "natural-blackjack",
    "outputId": "ef503dba-6dd8-43e7-deec-b1287a05d254"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 2 3]\n",
      " [4 5 6]\n",
      " [7 8 9]]\n",
      "transpose : \n",
      "[[1 4 7]\n",
      " [2 5 8]\n",
      " [3 6 9]]\n"
     ]
    }
   ],
   "source": [
    "a = np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])\n",
    "print(a)\n",
    "print(\"transpose : \")\n",
    "print(np.transpose(a))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "narrow-response",
   "metadata": {
    "id": "narrow-response"
   },
   "source": [
    "### 6.3 numpy.concatenate((a1, a2, ...), axis=0, out=None)\n",
    "\n",
    "Join a sequence of arrays along an existing axis.\n",
    "\n",
    " * a1, a2, ...: The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default).\n",
    " * axis:The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "id": "little-export",
   "metadata": {
    "id": "little-export",
    "outputId": "adbd2e05-14fe-4bae-fc08-7c8db99297f8"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a \n",
      " [[0 1 2]\n",
      " [3 4 5]]\n",
      "b \n",
      " [[ 7  8  9]\n",
      " [10 11 12]]\n"
     ]
    }
   ],
   "source": [
    "a = np.arange(6).reshape(2,3)\n",
    "b = np.arange(7,13).reshape(2,3)\n",
    "\n",
    "print(\"a \\n\",a)\n",
    "print(\"b \\n\",b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "id": "radical-geology",
   "metadata": {
    "id": "radical-geology",
    "outputId": "1215f26c-5780-4b84-e7b4-c76e0d90352f"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 0  1  2]\n",
      " [ 3  4  5]\n",
      " [ 7  8  9]\n",
      " [10 11 12]]\n",
      "\n",
      "[[ 0  1  2  7  8  9]\n",
      " [ 3  4  5 10 11 12]]\n"
     ]
    }
   ],
   "source": [
    "print(np.concatenate((a,b), axis = 0)) #axis=0 row\n",
    "print()\n",
    "print(np.concatenate((a,b), axis = 1)) #axis=1 col"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "id": "fuzzy-completion",
   "metadata": {
    "id": "fuzzy-completion",
    "outputId": "b89c9cb9-f793-456b-f51a-c7f94b2e8e8c"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 0  1  2]\n",
      " [ 3  4  5]\n",
      " [ 7  8  9]\n",
      " [10 11 12]]\n"
     ]
    }
   ],
   "source": [
    "print(np.concatenate((a,b)))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "empirical-option",
   "metadata": {
    "id": "empirical-option"
   },
   "source": [
    "## 6.7 numpy.delete(arr, obj, axis=None)\n",
    "\n",
    "Return a new array with sub-arrays along an axis deleted. For a one dimensional array, this returns\n",
    "those entries not returned by arr[obj]."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "id": "built-inventory",
   "metadata": {
    "id": "built-inventory",
    "outputId": "a8941714-2dbf-47b5-b1b9-a01d06e63499"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a= \n",
      " [[0 1 2]\n",
      " [3 4 5]]\n",
      "b= \n",
      " [[0 2]\n",
      " [3 5]]\n",
      "c= \n",
      " [0 2 3 4 5]\n"
     ]
    }
   ],
   "source": [
    "a = np.arange(6).reshape(2,3)\n",
    "b = np.delete(a,1,axis=1)   \n",
    "c = np.delete(a,1)\n",
    "print('a= \\n',a)\n",
    "print('b= \\n',b)\n",
    "print('c= \\n',c)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "intensive-lithuania",
   "metadata": {
    "id": "intensive-lithuania"
   },
   "source": [
    "# 7. Matrix\n",
    "\n",
    "This module contains all functions in the numpy namespace, with the following replacement functions that return matrices instead of ndarrays.\n",
    "\n",
    " * empty(shape[, dtype, order])\n",
    " \n",
    "   Return a new matrix of given shape and type, without initializing entries.\n",
    "   \n",
    " * zeros(shape[, dtype, order])\n",
    " \n",
    "   Return a matrix of given shape and type, filled with zeros.\n",
    "   \n",
    " * ones(shape[, dtype, order])\n",
    "    Return Matrix of ones.\n",
    "    \n",
    " * eye(n[, M, k, dtype, order])\n",
    " \n",
    "   Return a matrix with ones on the diagonal and zeros elsewhere.\n",
    "   \n",
    " * identity(n[, dtype])\n",
    " \n",
    "   Returns the square identity matrix of given size.\n",
    "   \n",
    " * repmat(a, m, n)\n",
    " \n",
    "   Repeat a 0-D to 2-D array or matrix MxN times.\n",
    "   \n",
    " * rand(*args)\n",
    " \n",
    "   Return a matrix of random values with given shape.\n",
    "   \n",
    " * randn(*args)\n",
    " \n",
    "   Return a random matrix with data from the “standard normal” distribution."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "chronic-dancing",
   "metadata": {
    "id": "chronic-dancing"
   },
   "source": [
    "##  7.1 creat a matrix by np.matlib.zeros() and np.matlib.ones()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "id": "careful-aggregate",
   "metadata": {
    "id": "careful-aggregate"
   },
   "outputs": [],
   "source": [
    "from numpy import matlib"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "id": "golden-peeing",
   "metadata": {
    "id": "golden-peeing",
    "outputId": "eedef162-bee7-42ac-e37c-5a5fcb65368b"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a=\n",
      "[[0. 0.]\n",
      " [0. 0.]]\n",
      "b=\n",
      "[[1. 1.]\n",
      " [1. 1.]]\n"
     ]
    }
   ],
   "source": [
    "a=matlib.zeros((2,2)) # matrix full of zeros\n",
    "b=matlib.ones((2,2)) # matrix full of ones\n",
    "print('a=')\n",
    "print(a)\n",
    "print('b=')\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "behavioral-grass",
   "metadata": {
    "id": "behavioral-grass"
   },
   "source": [
    "### 7.2 creat a diagonal matrix by np.matlib.eye()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "id": "stable-breakfast",
   "metadata": {
    "id": "stable-breakfast",
    "outputId": "3533afce-fe4e-4e74-b67b-126175d8f21e"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "c=\n",
      "[[0. 0.]\n",
      " [0. 0.]]\n"
     ]
    }
   ],
   "source": [
    "c=np.mat(a)\n",
    "print('c=')\n",
    "print(c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "id": "cef6e961-c7d7-41eb-8de6-da6402a1c2ec",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "numpy.matrix"
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(c)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ruled-lemon",
   "metadata": {
    "id": "ruled-lemon"
   },
   "source": [
    "### 7.3 transfer between array and matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "id": "signal-fleet",
   "metadata": {
    "id": "signal-fleet",
    "outputId": "d3cfef71-19c4-432c-b823-54268447af80"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 2]\n",
      " [3 4]]\n",
      "<class 'numpy.matrix'>\n",
      "matrix a=\n",
      "[[1 2 3]\n",
      " [4 5 6]]\n",
      "<class 'numpy.matrix'>\n",
      "array b=\n",
      "[[1 2 3]\n",
      " [4 5 6]]\n",
      "<class 'numpy.ndarray'>\n"
     ]
    }
   ],
   "source": [
    "# transfer an array to a matrix\n",
    "d = np.array([[1,2],[3,4]])\n",
    "d = np.mat(d)\n",
    "print(d)\n",
    "print(type(d))\n",
    "# transfer a matrix to an array\n",
    "a=np.mat([[1,2,3],[4,5,6]])\n",
    "b=a.getA()\n",
    "print('matrix a=')\n",
    "print(a)\n",
    "print(type(a))\n",
    "print('array b=')\n",
    "print(b)\n",
    "print(type(b))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "floating-plaintiff",
   "metadata": {
    "id": "floating-plaintiff"
   },
   "source": [
    "### 7.4 randomly create a matrix by np.matlib.rand()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "id": "european-trace",
   "metadata": {
    "id": "european-trace",
    "outputId": "4c29abc0-9660-4514-e298-fc3630a2f2a0"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a= [[0.89617721 0.25783038 0.04203047]\n",
      " [0.52925774 0.55266189 0.18996453]\n",
      " [0.68072943 0.61933083 0.96932877]]\n"
     ]
    }
   ],
   "source": [
    "from numpy import matlib\n",
    "a=matlib.rand(3,3)  #0-->1\n",
    "print('a=',a) "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "sixth-faith",
   "metadata": {
    "id": "sixth-faith"
   },
   "source": [
    "### 7.7 matrix operations\n",
    "\n",
    "matrix.dot(b, out=None) / numpy.dot(a, b, out=None)\n",
    "\n",
    "Dot product of two arrays.\n",
    "\n",
    "Dot product of two arrays. Specifically,\n",
    "\n",
    "* If both a and b are 1-D arrays, it is inner product of vectors (without complex conjugation).\n",
    "\n",
    "* If both a and b are 2-D arrays, it is matrix multiplication, but using matmul or a @ b is preferred.\n",
    "\n",
    "* If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred.\n",
    "\n",
    "* If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.\n",
    "\n",
    "* If a is an N-D array and b is an M-D array (where M>=2), it is a sum product over the last axis of a and the second-to-last axis of b:\n",
    "\n",
    "  * dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "id": "assumed-sustainability",
   "metadata": {
    "id": "assumed-sustainability",
    "outputId": "21402ec0-5769-400f-c5aa-4be4021c3a5f"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a\n",
      "[[1 0]\n",
      " [0 1]]\n",
      "b\n",
      "[[1 1]\n",
      " [2 2]]\n",
      "######\n",
      "[[1 1]\n",
      " [2 2]]\n",
      "######\n",
      "[[1 1]\n",
      " [2 2]]\n",
      "######\n",
      "[[1 1]\n",
      " [2 2]]\n",
      "######\n",
      "[[1 0]\n",
      " [0 2]]\n",
      "######\n",
      "[[1 0]\n",
      " [0 2]]\n"
     ]
    }
   ],
   "source": [
    "a = np.array([[1, 0], [0, 1]])\n",
    "b = np.array([[1, 1], [2, 2]])\n",
    "print(\"a\")\n",
    "print(a)\n",
    "print(\"b\")\n",
    "print(b)\n",
    "print(\"######\")\n",
    "print(np.dot(a, b)) # matrix multiplication\n",
    "print(\"######\")\n",
    "print(a@b) # matrix multiplication\n",
    "print(\"######\")\n",
    "print(np.matmul(a,b))\n",
    "print(\"######\")\n",
    "print(np.multiply(a,b)) #*\n",
    "print(\"######\")\n",
    "print(a*b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "id": "collaborative-delay",
   "metadata": {
    "id": "collaborative-delay",
    "outputId": "5b9f3a16-afe0-4379-93fb-6d36343059cb"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 0]\n",
      " [0 2]]\n",
      "[[1 0]\n",
      " [0 2]]\n"
     ]
    }
   ],
   "source": [
    "print(np.multiply(a,b)) # equivalent to multiply\n",
    "print(a*b) # equivalent to multiply"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "educated-recall",
   "metadata": {
    "id": "educated-recall"
   },
   "source": [
    "## # 7.5 mat/matrix/asmatrix:\n",
    "\n",
    "Functions that are also in the numpy namespace and return matrices\n",
    "\n",
    " * mat(data[, dtype])\n",
    "  * Interpret the input as a matrix.\n",
    " * matrix(data[, dtype, copy])\n",
    "  * Note: It is no longer recommended to use this class, even for linear\n",
    " * asmatrix(data[, dtype])\n",
    "  * Interpret the input as a matrix."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "id": "chubby-admission",
   "metadata": {
    "id": "chubby-admission",
    "outputId": "1ba5e2ac-a8f3-4d00-e394-1dbd4d0e86e1"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "array a=\n",
      "[1 2 3]\n",
      "matrix b=\n",
      "[[1 2 3]]\n",
      "matrix c=\n",
      "[[1 2 3]]\n",
      "matrix d=\n",
      "[[1 2 3]]\n"
     ]
    }
   ],
   "source": [
    "a=np.array([1,2,3])\n",
    "b=np.mat(a)\n",
    "d=np.asmatrix(a)\n",
    "c=np.matrix(a)\n",
    "print('array a=')\n",
    "print(a)\n",
    "print('matrix b=')\n",
    "print(b)\n",
    "print('matrix c=')\n",
    "print(c)\n",
    "print('matrix d=')\n",
    "print(d)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "minor-livestock",
   "metadata": {
    "id": "minor-livestock"
   },
   "source": [
    "### 7.8 Matrix Inverse"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "id": "frequent-ordinance",
   "metadata": {
    "id": "frequent-ordinance",
    "outputId": "908f7d0e-a038-4190-eb31-22ece67626da"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "matrix a=\n",
      "[[2 0 0]\n",
      " [0 1 0]\n",
      " [0 0 2]]\n",
      "matrix b=\n",
      "[[0.5 0.  0. ]\n",
      " [0.  1.  0. ]\n",
      " [0.  0.  0.5]]\n"
     ]
    }
   ],
   "source": [
    "a=np.matrix([[2,0,0],\n",
    "[0,1,0],\n",
    "[0,0,2]])\n",
    "b=a.I \n",
    "print('matrix a=')\n",
    "print(a)\n",
    "print('matrix b=')\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fossil-punishment",
   "metadata": {
    "id": "fossil-punishment"
   },
   "source": [
    "### 7.9 Determinant of a Matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "id": "ancient-tuesday",
   "metadata": {
    "id": "ancient-tuesday",
    "outputId": "76af6997-c9dd-4b49-9eab-4968722e0522"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "matrix a=\n",
      "[[1 2]\n",
      " [3 4]]\n",
      " b=\n",
      "-2.0000000000000004\n"
     ]
    }
   ],
   "source": [
    "# |A|\n",
    "\n",
    "a=np.matrix([[1,2],\n",
    "[3,4]])\n",
    "\n",
    "b=np.linalg.det(a)\n",
    "print('matrix a=')\n",
    "print(a)\n",
    "print(' b=')\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "humanitarian-evans",
   "metadata": {
    "id": "humanitarian-evans"
   },
   "source": [
    "### 7.10 sum,max,min"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "id": "lovely-israeli",
   "metadata": {
    "id": "lovely-israeli",
    "outputId": "ea2a24e2-bb8b-4a0d-e342-3e6cbbff4149"
   },
   "outputs": [
    {
     "data": {
      "text/plain": "matrix([[1, 2],\n        [3, 4]])"
     },
     "execution_count": 96,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a=np.matrix([[1,2],\n",
    "[3,4]])\n",
    "a"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "id": "colored-plate",
   "metadata": {
    "id": "colored-plate",
    "outputId": "28cb5662-ddee-42b9-9497-bc68c0d64683"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " b= [[4 6]]\n",
      " c=\n",
      "[[3]\n",
      " [7]]\n"
     ]
    }
   ],
   "source": [
    "b=a.sum(axis=0)  #sum by columns\n",
    "c=a.sum(axis=1)  #sum of raws\n",
    "\n",
    "print(' b=',b)\n",
    "print(' c=')\n",
    "print(c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "id": "eligible-warehouse",
   "metadata": {
    "id": "eligible-warehouse",
    "outputId": "865da5d9-d197-444c-f0c8-b0a8aa1a0705"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " d= 4\n",
      " e= 1\n"
     ]
    }
   ],
   "source": [
    "d=a.max()\n",
    "e=a.min()\n",
    "print(' d=',d)\n",
    "print(' e=',e)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8f59cfac-890d-4339-a102-2a777c566554",
   "metadata": {},
   "source": [
    "# 8.Tensor\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "id": "fb66a808-070e-4dfd-a0a8-1f8168237d80",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Tesnor : \n",
      " [[[1 2]\n",
      "  [3 4]\n",
      "  [5 5]]\n",
      "\n",
      " [[1 2]\n",
      "  [3 4]\n",
      "  [5 5]]\n",
      "\n",
      " [[1 2]\n",
      "  [3 4]\n",
      "  [5 5]]]\n"
     ]
    }
   ],
   "source": [
    "T1=np.array([[[1,2],[3,4],[5,5]],[[1,2],[3,4],[5,5]],[[1,2],[3,4],[5,5]]])\n",
    "T2=np.array([[[1,2],[3,4],[5,5]],[[1,2],[3,4],[5,5]],[[1,2],[3,4],[5,5]]])\n",
    "\n",
    "print(\"Tesnor : \\n\",T1)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "78fb7ea2-2957-44da-9ff8-7b37736f4c40",
   "metadata": {},
   "source": [
    "## 8.1 Matrix Addition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "id": "cccba2e9-5326-4f43-9e1a-0f255008d528",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([[[ 2,  4],\n        [ 6,  8],\n        [10, 10]],\n\n       [[ 2,  4],\n        [ 6,  8],\n        [10, 10]],\n\n       [[ 2,  4],\n        [ 6,  8],\n        [10, 10]]])"
     },
     "execution_count": 100,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "T1+T2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "08d90b76-1013-4958-9727-11e43829123d",
   "metadata": {},
   "source": [
    "## 8.2 Matrix Multiplication"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "id": "7d5b0d44-d228-4307-bc4b-7dc9fe95a6e9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([[[ 1,  4],\n        [ 9, 16],\n        [25, 25]],\n\n       [[ 1,  4],\n        [ 9, 16],\n        [25, 25]],\n\n       [[ 1,  4],\n        [ 9, 16],\n        [25, 25]]])"
     },
     "execution_count": 101,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "T1*T2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "02abb0bd-5861-4dbc-bc13-d084bd578cd9",
   "metadata": {},
   "source": [
    "## 8.1Tensor Product"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "id": "47001e4f-08f9-4586-b128-0c7f74c8aa8a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[[[ 5  6]\n",
      "   [ 7  8]]\n",
      "\n",
      "  [[10 12]\n",
      "   [14 16]]]\n",
      "\n",
      "\n",
      " [[[15 18]\n",
      "   [21 24]]\n",
      "\n",
      "  [[20 24]\n",
      "   [28 32]]]]\n"
     ]
    }
   ],
   "source": [
    "A=np.array([[1,2],[3,4]])\n",
    "B=np.array([[5,6],[7,8]])\n",
    "c=np.tensordot(A,B,axes=0)\n",
    "\"\"\"\n",
    "axes = 0 : tensor product a@b\n",
    "\n",
    "axes = 1 : tensor dot product a.b\n",
    "\n",
    "axes = 2 : (default) tensor double contraction a:b\n",
    "\"\"\"\n",
    "\n",
    "print(c)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f85065fd-03ae-43c5-94c9-b873a90ed998",
   "metadata": {},
   "source": [
    "# Eigen Decomposition "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "id": "7b2fc5fc-ca81-4e9d-8a6b-7fcc2dfdc721",
   "metadata": {},
   "outputs": [],
   "source": [
    "A=np.array([[1,2,3],[4,5,6],[7,8,9]])\n",
    "values,vectors =np.linalg.eig(A)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "id": "f59d930a-ca7c-41ea-abab-5804928b971c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "(array([[-0.23197069, -0.78583024,  0.40824829],\n        [-0.52532209, -0.08675134, -0.81649658],\n        [-0.8186735 ,  0.61232756,  0.40824829]]),\n array([ 1.61168440e+01, -1.11684397e+00, -3.38433605e-16]))"
     },
     "execution_count": 104,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "vectors,values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "id": "f26e6c38-9b4c-4247-9894-15c94a8f3279",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([[1., 2., 3.],\n       [4., 5., 6.],\n       [7., 8., 9.]])"
     },
     "execution_count": 105,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "R=np.linalg.inv(vectors)\n",
    "L=np.diag(values)\n",
    "B=vectors.dot(L).dot(R)\n",
    "B"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [
    "encouraging-cambodia",
    "modular-timer",
    "agreed-proposal",
    "detailed-attempt",
    "cheap-seeking",
    "arctic-large",
    "welsh-appreciation",
    "chubby-mother",
    "descending-smooth",
    "narrow-response",
    "empirical-option",
    "chronic-dancing",
    "behavioral-grass",
    "ruled-lemon",
    "floating-plaintiff",
    "sixth-faith",
    "educated-recall",
    "minor-livestock",
    "fossil-punishment",
    "humanitarian-evans",
    "romance-russian",
    "normal-render",
    "endangered-night",
    "found-values",
    "absent-feature",
    "supreme-blair",
    "efficient-childhood",
    "difficult-amazon",
    "streaming-cattle",
    "corrected-transcript",
    "large-server",
    "choice-frank",
    "medical-constraint",
    "color-material",
    "binary-farmer",
    "extreme-morning",
    "august-laundry",
    "commercial-freeze",
    "indoor-lawsuit",
    "buried-wales",
    "medical-falls",
    "ancient-connecticut",
    "optical-audio",
    "cordless-intake",
    "generous-title",
    "handmade-vietnam",
    "bacterial-reference",
    "statistical-longitude",
    "artificial-boulder",
    "authorized-warrant",
    "configured-grove",
    "coupled-indie",
    "respective-laugh",
    "interpreted-musical",
    "unauthorized-agriculture",
    "fourth-feedback"
   ],
   "name": "Third_party_Liberaries_U.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
